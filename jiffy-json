#!/usr/bin/env python2.7
import re
import sys
from collections import OrderedDict

VERSION = '1.0.0'
STRING_CAST_TAG = "@S"


def main():
    cli = parse_cli()
    args = parse_arguments(cli.args)
    result = build_result(args)
    print(result_as_json(result))


# #################### Argument Parsing #################### #


class ArgumentError(Exception):
    def __init__(self, message):
        super(ArgumentError, self).__init__(message)


def parse_arguments(argv):
    try:
        return list(_gen_arguments(argv))
    except ArgumentError as e:
        print("Error: {}".format(e.message))
        sys.exit(2)


class ArgumentContext:
    def __init__(self, path, is_object, is_implicit=False):
        self.path = path
        self.is_object = is_object
        self.is_implicit = is_implicit
        self.ndx = 0


def _gen_arguments(argv):
    context_stack = []
    for ndx, raw in enumerate(argv):
        curr_stack = context_stack[-1] if context_stack else None
        if raw == '}':
            if not curr_stack:
                raise ArgumentError("cannot close object builder; none to close: Argument #{}".format(ndx))
            if not curr_stack.is_object:
                raise ArgumentError("cannot close object builder; in array builder: Argument #{}".format(ndx))
            context_stack.pop()
            continue

        if raw == ']':
            if not context_stack:
                raise ArgumentError("cannot close array builder; none to close: Argument #{}".format(ndx))
            if curr_stack.is_object:
                raise ArgumentError("cannot close array builder; in object builder: Argument #{}".format(ndx))
            context_stack.pop()
            continue

        m = re.search(r'(?<!\\):', raw)
        if m:
            if not curr_stack:
                curr_stack = ArgumentContext([], True, is_implicit=True)
                context_stack.append(curr_stack)

            if not curr_stack.is_object:
                raise ArgumentError("items in an array may not have a key: {}".format(raw))

            key = raw[0:m.start()]
            value = raw[m.start() + 1:]
            path = curr_stack.path + list(_gen_path(key))  # TODO edge case: a{ [0]:1 }

            yield Argument(key, path, _auto_cast(value))
            continue

        m = re.search(r'(?<!\\)\{$', raw)
        if m:
            path = curr_stack.path if curr_stack else []

            key = raw[0:m.start()]
            if not key:
                if curr_stack:
                    if curr_stack.is_object:
                        raise ArgumentError("items in an object require a key and value: " + raw)
                    else:
                        path = path + [ArgPathArrayItem(curr_stack.ndx)]
                        curr_stack.ndx += 1
            if key:
                if curr_stack and not curr_stack.is_object:
                    raise ArgumentError("items in an array may not have a key: " + raw)

                path = path + list(_gen_path(key))
            context_stack.append(ArgumentContext(path, True))
            continue

        m = re.search(r'(?<!\\)\[$', raw)
        if m:
            path = curr_stack.path if curr_stack else []
            key = raw[0:m.start()]
            if not key:
                if curr_stack:
                    if curr_stack.is_object:
                        raise ArgumentError("items in an object require a key and value: " + raw)
                    else:
                        path = path + [ArgPathArrayItem(curr_stack.ndx)]
                        curr_stack.ndx += 1
            else:
                if curr_stack and not curr_stack.is_object:
                    raise ArgumentError("items in an array may not have a key: " + raw)

                path = path + list(_gen_path(key))
            context_stack.append(ArgumentContext(path, False))
            continue

        if not curr_stack or curr_stack.is_object:
            raise ArgumentError("items in an object require a key and value: " + raw)

        path = curr_stack.path + [ArgPathArrayItem(curr_stack.ndx)]
        yield Argument(None, path, _auto_cast(raw))
        curr_stack.ndx += 1

    if context_stack:
        curr_stack = context_stack[-1]
        if curr_stack.is_object:
            if not curr_stack.is_implicit:
                raise ArgumentError("object builder is unclosed")
        else:
            raise ArgumentError("array builder is unclosed")


def _gen_path(key):
    arr_indices = [m.start() for m in re.finditer(r'(?<!\\)\[\d+]', key)]
    lk = list(key)
    for ndx in reversed(arr_indices):
        if ndx != 0:
            lk.insert(ndx, '.')
    key = ''.join(lk)

    parts = re.split(r'(?<!\\)\.', key)
    for item in parts:
        arr_match = re.match(r'^\[(\d+)\]$', item)
        if arr_match:
            yield ArgPathArrayItem(arr_match.group(1))
        else:
            yield ArgPathObjectItem(item)


def _auto_cast(value):
    if value.endswith(STRING_CAST_TAG):
        return value[:-len(STRING_CAST_TAG)]
    if value == "[]":
        return []
    elif value == "{}":
        return OrderedDict()
    elif value == "null":
        return JsonNull
    elif value == "true":
        return True
    elif value == "false":
        return False
    elif re.match(r'^\d+$', value):
        return int(value)
    elif re.match(r'^[\d.]+$', value):
        return float(value)
    else:
        return value


# #################### Result Builder #################### #

class JiffyError(Exception):
    def __init__(self, message, argument):
        super(JiffyError, self).__init__(message)
        self.argument = argument


def build_result(args):
    if not args:
        return OrderedDict()

    result = args[0].path[0].create_collection()

    try:
        for a in args:
            a.fill_result(result)
        return result
    except JiffyError as e:
        print("Error: {}".format(e.message))
        print("Argument: {}".format(str(e.argument)))
        print("State: {}".format(result_as_json(result)))
        sys.exit(1)


# We use None to track unset values
JsonNull = object()


class Argument:
    def __init__(self, raw_key, path, value):
        self.raw_key = raw_key
        self.path = path
        self.value = value

    def fill_result(self, result):
        target = result
        for ndx, item in enumerate(self.path[:-1]):
            target = item.next_target(self, target, self.path[ndx + 1])

        item = self.path[-1]
        item.set_in_result(self, target)

    def __str__(self):
        if self.raw_key is None:
            return repr(self.value)
        else:
            return '{}:{}'.format(self.raw_key, repr(self.value))

    def __repr__(self):
        return '<{}>:{}'.format(','.join(map(repr, self.path)), repr(self.value))


class ArgPathArrayItem:
    def __init__(self, ndx):
        self.ndx = int(ndx)

    def create_collection(self):
        return []

    def next_target(self, argument, target, next_item):
        if _json_type(target) != 'array':
            raise JiffyError("cannot treat {} as array".format(_json_type(target)), argument)

        if self.ndx is None:
            raise JiffyError("push syntax can only be used at end of path", argument)

        while self.ndx >= len(target):
            target.append(None)

        if target[self.ndx] is None:
            target[self.ndx] = next_item.create_collection()

        return target[self.ndx]

    def set_in_result(self, argument, target):
        if _json_type(target) != 'array':
            raise JiffyError("cannot treat {} as array".format(_json_type(target)), argument)

        target_ndx = self.ndx
        if target_ndx is None:
            target_ndx = len(target)

        while target_ndx >= len(target):
            target.append(None)

        if target[target_ndx] is not None:
            raise JiffyError("array index is already set", argument)

        target[target_ndx] = argument.value

    def __repr__(self):
        return "PArr({})".format(self.ndx)


class ArgPathObjectItem:
    def __init__(self, key):
        key = re.sub(r'\\([:\[(.])', r'\1', key)

        self.key = key

    def create_collection(self):
        return OrderedDict()

    def next_target(self, argument, target, next_item):
        if _json_type(target) != 'object':
            raise JiffyError("cannot treat {} as object".format(_json_type(target)), argument)

        if self.key not in target:
            target[self.key] = next_item.create_collection()

        return target[self.key]

    def set_in_result(self, argument, target):
        if _json_type(target) != 'object':
            raise JiffyError("cannot treat {} as object".format(_json_type(target)), argument)

        if self.key in target:
            raise JiffyError("object property is already set", argument)
        target[self.key] = argument.value

    def __repr__(self):
        return "PObj({})".format(self.key)


def _json_type(target):
    if target is JsonNull:
        return "null"
    if target is True or target is False:
        return "bool"
    if isinstance(target, list):
        return "array"
    if isinstance(target, dict):
        return "object"
    if isinstance(target, (int, float, long)):
        return "number"
    if isinstance(target, str):
        return "string"
    return type(target)


# #################### Output #################### #


def result_as_json(obj):
    from json import JSONEncoder

    def default(o):
        if o is JsonNull:
            return None
        raise TypeError(repr(o) + " is not JSON serializable")

    encoder = JSONEncoder(separators=(',', ':'), default=default)
    return encoder.encode(obj)


# #################### CLI and Help #################### #


def parse_cli():
    import argparse
    global STRING_CAST_TAG
    ap = argparse.ArgumentParser(
        description="Build JSON in a jiffy",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=build_help_text())
    ap.add_argument('-v', '--version', action='version', version="jiffy-json " + VERSION)
    ap.add_argument('--string-cast', nargs=1, metavar='TAG', default=[STRING_CAST_TAG],
                    help='Specifies the value suffix which forces the value '
                         'to be cast as a string. Defaults to "{}"'.format(STRING_CAST_TAG))
    ap.add_argument('args', nargs=argparse.REMAINDER, help=argparse.SUPPRESS)
    result = ap.parse_args()

    STRING_CAST_TAG = result.string_cast[0]

    return result


def build_help_text():
    # TODO document builder
    from textwrap import dedent
    #   Aim to keep the message within 70 characters
    #   1234567890123456789012345678901234567890123456789012345678901234567890
    return dedent("""\
        Arguments are used to build the JSON result. They follow a few rules:
        * Each argument is a colon separated path:value pair
        * In the path,  .    may separate keys to form nested objects
        * In the path,  [N]  may separate keys to form nested arrays
          The N is an integer to add the value or nested object at that index.
        * Values will be type-cast if possible. Appending  @S  to the value
          will prevent type-casting. --string-cast controls this suffix.

        Examples:

        %(prog)s foo.bar:"hello world"
          {"foo":{"bar":"hello world"}}

        %(prog)s abc:100 def:200@S
          {"abc":100, "def":"200"}

        %(prog)s l[0].a:1 l[0].b:2 l[1]:3
          {"l":[{"a":1, "b":2}, 3]}
        """)


if __name__ == "__main__":
    main()
