#!/usr/bin/env python2.7
import re
import sys
from collections import OrderedDict

VERSION = '1.0.0'
STRING_CAST_TAG = "@S"


def main():
    cli = parse_cli()

    try:
        args = list(gen_arguments(cli.args))
    except ArgumentError as e:
        print("Error: {}".format(e.message))
        sys.exit(2)

    result = create_base_collection(args)

    try:
        for a in args:
            a.fill_result(result)
        print(build_json_result(result))
    except JiffyError as e:
        print("Error: {}".format(e.message))
        print("Argument: {}".format(repr(e.argument)))
        print("State: {}".format(build_json_result(result)))
        sys.exit(1)


def gen_arguments(argv):
    for raw in argv:
        m = re.search(r'(?<!\\):', raw)
        if not m:
            raise ArgumentError("unable to parse argument: " + raw)

        key = raw[0:m.start()]
        value = raw[m.start() + 1:]
        path = list(gen_path(key))

        yield Argument(key, path, auto_cast(value))


def gen_path(key):
    arr_indices = [m.start() for m in re.finditer(r'(?<!\\)\[\d+]', key)]
    lk = list(key)
    for ndx in reversed(arr_indices):
        if ndx != 0:
            lk.insert(ndx, '.')
    key = ''.join(lk)

    parts = re.split(r'(?<!\\)\.', key)
    for item in parts:
        arr_match = re.match(r'^\[(\d+)\]$', item)
        if arr_match:
            yield ArgPathArrayItem(arr_match.group(1))
        else:
            yield ArgPathObjectItem(item)


def create_base_collection(args):
    if len(args):
        return args[0].path[0].create_collection()
    else:
        return OrderedDict()


def json_type(target):
    if target is JsonNull:
        return "null"
    if target is True or target is False:
        return "bool"
    if isinstance(target, list):
        return "array"
    if isinstance(target, dict):
        return "object"
    if isinstance(target, (int, float, long)):
        return "number"
    if isinstance(target, str):
        return "string"
    return type(target)


def auto_cast(value):
    if value.endswith(STRING_CAST_TAG):
        return value[:-len(STRING_CAST_TAG)]
    if value == "[]":
        return []
    elif value == "{}":
        return OrderedDict()
    elif value == "null":
        return JsonNull
    elif value == "true":
        return True
    elif value == "false":
        return False
    elif re.match(r'^\d+$', value):
        return int(value)
    elif re.match(r'^[\d.]+$', value):
        return float(value)
    else:
        return value


def build_json_result(obj):
    from json import JSONEncoder

    def default(o):
        if o is JsonNull:
            return None
        raise TypeError(repr(o) + " is not JSON serializable")

    encoder = JSONEncoder(separators=(',', ':'), default=default)
    return encoder.encode(obj)


# We use None to track unset values.
JsonNull = object()


class JiffyError(Exception):
    def __init__(self, message, argument):
        super(JiffyError, self).__init__(message)
        self.argument = argument


class ArgumentError(Exception):
    def __init__(self, message):
        super(ArgumentError, self).__init__(message)


class Argument:
    def __init__(self, raw_key, path, value):
        self.raw_key = raw_key
        self.path = path
        self.value = value

    def fill_result(self, result):
        target = result
        for ndx, item in enumerate(self.path[:-1]):
            target = item.next_target(self, target, self.path[ndx + 1])

        item = self.path[-1]
        item.set_in_result(self, target)

    def __repr__(self):
        return '{}:{}'.format(self.raw_key, repr(self.value))


class ArgPathArrayItem:
    def __init__(self, ndx):
        self.ndx = int(ndx)

    def create_collection(self):
        return []

    def next_target(self, argument, target, next_item):
        if json_type(target) != 'array':
            raise JiffyError("cannot treat {} as array".format(json_type(target)), argument)

        if self.ndx is None:
            raise JiffyError("push syntax can only be used at end of path", argument)

        while self.ndx >= len(target):
            target.append(None)

        if target[self.ndx] is None:
            target[self.ndx] = next_item.create_collection()

        return target[self.ndx]

    def set_in_result(self, argument, target):
        if json_type(target) != 'array':
            raise JiffyError("cannot treat {} as array".format(json_type(target)), argument)

        target_ndx = self.ndx
        if target_ndx is None:
            target_ndx = len(target)

        while target_ndx >= len(target):
            target.append(None)

        if target[target_ndx] is not None:
            raise JiffyError("array index is already set", argument)

        target[target_ndx] = argument.value

    def __repr__(self):
        return "PathArr({})".format(self.ndx)


class ArgPathObjectItem:
    def __init__(self, key):
        key = re.sub(r'\\([:\[(.])', r'\1', key)

        self.key = key

    def create_collection(self):
        return OrderedDict()

    def next_target(self, argument, target, next_item):
        if json_type(target) != 'object':
            raise JiffyError("cannot treat {} as object".format(json_type(target)), argument)

        if self.key not in target:
            target[self.key] = next_item.create_collection()

        return target[self.key]

    def set_in_result(self, argument, target):
        if json_type(target) != 'object':
            raise JiffyError("cannot treat {} as object".format(json_type(target)), argument)

        if self.key in target:
            raise JiffyError("object property is already set", argument)
        target[self.key] = argument.value

    def __repr__(self):
        return "PathObj({})".format(self.key)


def parse_cli():
    import argparse
    global STRING_CAST_TAG
    ap = argparse.ArgumentParser(
        description="Build JSON in a jiffy",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=build_epilog())
    ap.add_argument('-v', '--version', action='version', version="jiffy-json " + VERSION)
    ap.add_argument('--string-cast', nargs=1, metavar='TAG', default=[STRING_CAST_TAG],
                    help='Specifies the value suffix which forces the value '
                         'to be cast as a string. Defaults to "{}"'.format(STRING_CAST_TAG))
    ap.add_argument('args', nargs=argparse.REMAINDER, help=argparse.SUPPRESS)
    result = ap.parse_args()

    STRING_CAST_TAG = result.string_cast[0]

    return result


def build_epilog():
    # TODO document builder
    from textwrap import dedent
    #   Aim to keep the message within 70 characters
    #   1234567890123456789012345678901234567890123456789012345678901234567890
    return dedent("""\
        Arguments are used to build the JSON result. They follow a few rules:
        * Each argument is a colon separated path:value pair
        * In the path,  .    may separate keys to form nested objects
        * In the path,  [N]  may separate keys to form nested arrays
          The N is an integer to add the value or nested object at that index.
        * Values will be type-cast if possible. Appending  @S  to the value
          will prevent type-casting. --string-cast controls this suffix.

        Examples:

        %(prog)s foo.bar:"hello world"
          {"foo":{"bar":"hello world"}}

        %(prog)s abc:100 def:200@S
          {"abc":100, "def":"200"}

        %(prog)s l[0].a:1 l[0].b:2 l[1]:3
          {"l":[{"a":1, "b":2}, 3]}
        """)


if __name__ == "__main__":
    main()
